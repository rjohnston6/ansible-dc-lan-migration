---
# Playbook: 1.3-deploy-vpc-domain.yml
# Purpose: Configure and deploy VPC domain to Nexus Dashboard using REST API
#
# Description:
#   This playbook configures VPC domains on aggregation switches by:
#   1. Querying switches to get serial numbers and IP addresses
#   2. Checking if VPC pairs already exist in NDFC via REST API
#   3. Building VPC pair configuration from J2 template
#   4. Deploying VPC domains via cisco.nd.nd_rest module
#
# Variables Required:
#   - vpc_domains: List of VPC domain definitions (from fabric_definitions.yml)
#
# Module Used:
#   - cisco.nd.nd_rest: ND REST API module for VPC pair management
#
# API Endpoint:
#   - /appcenter/cisco/ndfc/api/v1/lan-fabric/rest/vpcpair
#
# Templates Used:
#   - 1.3-deploy-vpc-domain.json.j2: Jinja2 template for VPC pair API payload
#
# Tags:
#   - deploy-vpc-domain: Run only VPC domain deployment tasks
#
# Example Usage:
#   ansible-playbook ./playbooks/provision-switch/1.3-deploy-vpc-domain.yml

- name: Configure and Deploy VPC Domain in Nexus Dashboard
  hosts: nexus_dashboard
  gather_facts: false

  vars:
    vpc_api_path: "/appcenter/cisco/ndfc/api/v1/lan-fabric/rest/vpcpair"

  tags:
    - deploy-vpc-domain

  tasks:

    #--------------------------------------------------------------------------
    # Pre-flight: Verify NDFC is reachable before any provisioning
    #--------------------------------------------------------------------------
    - name: Verify NDFC connectivity
      ansible.builtin.import_tasks: ../common/ndfc-preflight-check.yml

    # ========================================================================
    # Phase 1: Early exit check
    # ========================================================================

    - name: Set target fabric name from nd_fabrics
      ansible.builtin.set_fact:
        target_fabric: "{{ nd_fabrics[0].FABRIC_NAME }}"

    - name: Filter VPC domains to target fabric only
      ansible.builtin.set_fact:
        vpc_domains_filtered: "{{ vpc_domains | default([]) | selectattr('FABRIC_NAME', 'equalto', target_fabric) | list }}"

    - name: End play if no VPC domains defined
      ansible.builtin.meta: end_play
      when: vpc_domains_filtered | length == 0

    # ========================================================================
    # Phase 2: Query switches to get IP addresses and serial numbers
    # ========================================================================

    - name: Query all switches in target fabric
      cisco.nd.nd_rest:
        host: "{{ ansible_host }}"
        username: "{{ ansible_user }}"
        password: "{{ ansible_password }}"
        use_ssl: "{{ ansible_httpapi_use_ssl }}"
        validate_certs: "{{ ansible_httpapi_validate_certs }}"
        use_proxy: "{{ ansible_httpapi_use_proxy }}"
        login_domain: "{{ ansible_httpapi_login_domain }}"
        path: "/api/v1/manage/fabrics/{{ target_fabric }}/switches"
        method: GET
      register: fabric_switches_query

    - name: Build switch lookup by IP address
      ansible.builtin.set_fact:
        switch_lookup: |
          {%- set lookup = {target_fabric: {}} -%}
          {%- if fabric_switches_query.current is defined and fabric_switches_query.current.switches is defined -%}
            {%- for switch in fabric_switches_query.current.switches -%}
              {%- if switch.fabricManagementIp is defined -%}
                {%- set _ = lookup[target_fabric].update({switch.fabricManagementIp: {'serial': switch.serialNumber, 'ip': switch.fabricManagementIp, 'hostname': switch.hostname | default('')}}) -%}
              {%- endif -%}
            {%- endfor -%}
          {%- endif -%}
          {{ lookup }}

    # ========================================================================
    # Phase 3: Build VPC domain configurations with IP addresses and serials
    # ========================================================================

    - name: Build VPC domain configurations
      ansible.builtin.set_fact:
        vpc_domains_resolved: |
          {%- set domains = [] -%}
          {%- for domain in vpc_domains_filtered -%}
            {%- set fabric = domain.FABRIC_NAME -%}
            {%- if fabric in switch_lookup -%}
              {%- set fabric_switches = switch_lookup[fabric] -%}
              {# Resolve inventory hostnames to IP addresses via hostvars #}
              {%- set peer1_ip = hostvars[domain.PEER1_NAME]['ansible_host'] | default('') if domain.PEER1_NAME in hostvars else '' -%}
              {%- set peer2_ip = hostvars[domain.PEER2_NAME]['ansible_host'] | default('') if domain.PEER2_NAME in hostvars else '' -%}
              {%- if peer1_ip in fabric_switches and peer2_ip in fabric_switches -%}
                {%- set peer1_info = fabric_switches[peer1_ip] -%}
                {%- set peer2_info = fabric_switches[peer2_ip] -%}
                {%- set updated = domain | combine({
                  'PEER1_IP': peer1_info.ip,
                  'PEER2_IP': peer2_info.ip,
                  'PEER1_SERIAL': peer1_info.serial,
                  'PEER2_SERIAL': peer2_info.serial
                }) -%}
                {%- set _ = domains.append(updated) -%}
              {%- endif -%}
            {%- endif -%}
          {%- endfor -%}
          {{ domains }}

    # ========================================================================
    # Phase 4: Check for existing VPC pairs in NDFC via REST API
    # ========================================================================

    - name: Query existing VPC pairs in NDFC
      cisco.nd.nd_rest:
        host: "{{ ansible_host }}"
        username: "{{ ansible_user }}"
        password: "{{ ansible_password }}"
        use_ssl: "{{ ansible_httpapi_use_ssl }}"
        validate_certs: "{{ ansible_httpapi_validate_certs }}"
        use_proxy: "{{ ansible_httpapi_use_proxy }}"
        login_domain: "{{ ansible_httpapi_login_domain }}"
        path: "/api/v1/manage/fabrics/{{ target_fabric }}/vpcPairs"
        method: GET
      when: vpc_domains_resolved | length > 0
      register: existing_vpc_pairs

    - name: Build set of existing VPC pair serial numbers
      ansible.builtin.set_fact:
        existing_vpc_serials: |
          {%- set serials = [] -%}
          {%- for vpc in existing_vpc_pairs.current.vpcPairs | default([]) -%}
            {%- set _ = serials.append(vpc.peer1SwitchId | default('')) -%}
            {%- set _ = serials.append(vpc.peer2SwitchId | default('')) -%}
          {%- endfor -%}
          {{ serials | unique | reject('equalto', '') | list }}
      when: existing_vpc_pairs is defined

    - name: Filter out VPC domains where switches already have VPC configured
      ansible.builtin.set_fact:
        vpc_domains_to_create: |
          {%- set to_create = [] -%}
          {%- for domain in vpc_domains_resolved -%}
            {%- set ns = namespace(vpc_exists=false) -%}
            {%- for vpc in existing_vpc_pairs.current.vpcPairs | default([]) -%}
              {# Check if both peer serials match an existing VPC pair (in either order) #}
              {%- if (vpc.peer1SwitchId == domain.PEER1_SERIAL and vpc.peer2SwitchId == domain.PEER2_SERIAL) or
                     (vpc.peer1SwitchId == domain.PEER2_SERIAL and vpc.peer2SwitchId == domain.PEER1_SERIAL) -%}
                {%- set ns.vpc_exists = true -%}
              {%- endif -%}
            {%- endfor -%}
            {%- if not ns.vpc_exists -%}
              {%- set _ = to_create.append(domain) -%}
            {%- endif -%}
          {%- endfor -%}
          {{ to_create }}
      when: existing_vpc_pairs is defined

    - name: Display VPC creation status
      ansible.builtin.debug:
        msg: |
          ═══════════════════════════════════════════════════════════════════════
          VPC PAIR STATUS
          ═══════════════════════════════════════════════════════════════════════
          Defined in inventory : {{ vpc_domains_resolved | length }} VPC domain(s)
          Already in NDFC      : {{ vpc_domains_resolved | length - (vpc_domains_to_create | default([]) | length) }} (will be skipped)
          To be created        : {{ vpc_domains_to_create | default([]) | length }} (missing from NDFC)

          Inventory VPC domains:
          {% for domain in vpc_domains_resolved %}
            - Domain {{ domain.DOMAIN_ID }}: {{ domain.PEER1_NAME }} ({{ domain.PEER1_SERIAL }}) <-> {{ domain.PEER2_NAME }} ({{ domain.PEER2_SERIAL }})
              {{ 'SKIP - already in NDFC' if domain.PEER1_SERIAL in (existing_vpc_serials | default([])) or domain.PEER2_SERIAL in (existing_vpc_serials | default([])) else 'CREATE - missing from NDFC' }}
          {% endfor %}
          ═══════════════════════════════════════════════════════════════════════
      when: existing_vpc_pairs is defined

    # ========================================================================
    # Phase 5: Deploy VPC domains via REST API
    # ========================================================================

    # TODO: NDFC bug - VPC policy is not reliably attached during the discovery
    # workflow even when the VPC pair already exists in NDFC. As a workaround,
    # we POST all resolved VPC domains unconditionally (not just vpc_domains_to_create)
    # so the policy is always (re-)applied. Once the bug is confirmed fixed, restore
    # the original behaviour by changing the loop back to vpc_domains_to_create and
    # reinstating: when: vpc_domains_to_create | default([]) | length > 0
    # This task is expected to fail, but the POLICY element gets successfully created and 
    # attached to the VPC switch pair
    - name: Create VPC pairs via REST API
      cisco.dcnm.dcnm_rest:
        path: "{{ vpc_api_path }}"
        method: POST
        # dcnm_rest internally calls json.loads(json_data) - json_data must be a JSON string.
        # ansible-core 2.17 may auto-parse the template output to a native Python dict
        # (type="raw" does not prevent this). The conditional re-serializes it to a
        # JSON string if that happens.
        json_data: "{{ _payload | to_json if _payload is mapping else _payload }}"
      vars:
        _payload: "{{ lookup('template', playbook_dir + '/../../templates/1.3-deploy-vpc-domain.j2') }}"
      loop: "{{ vpc_domains_resolved | default([]) }}"
      loop_control:
        label: "Domain {{ item.DOMAIN_ID }}: {{ item.PEER1_NAME }} <-> {{ item.PEER2_NAME }}"
      register: vpc_create_results
      ignore_errors: true
      when: vpc_domains_resolved | default([]) | length > 0
