---
# Playbook: 1.0-preprovision-new-switches.yml
# Purpose: Pre-provision new switches or discover existing switches in NDFC
#
# Description:
#   This playbook adds switches to Nexus Dashboard Fabric Controller by:
#   1. Loading switch_details.yml to get current serial numbers
#   2. Comparing destination_switch_sn (hosts.yml) with serial_number (switch_details.yml):
#      - Match: Discover existing switch via Manage API (same hardware)
#      - Mismatch: Pre-provision new switch via POAP API (replacement hardware)
#
# Variables Required (per switch in hosts.yml):
#   - add_to_fabric: Set to true to include switch in provisioning
#   - fabric: Target fabric name
#   - role: Switch role (access, aggregation, etc.)
#   - ansible_host: Target switch management IP address
#   - destination_switch_sn: Target switch serial number (compared against switch_details.yml)
#
# For POAP Pre-provisioning (destination_switch_sn != switch_details serial):
#   - destination_switch_model: Target switch model (e.g., N9K-C9300v)
#   - destination_switch_version: Target NX-OS version (e.g., 10.6(1))
#
# For Discovery (destination_switch_sn == switch_details serial):
#   - No additional variables required beyond destination_switch_sn
#
# Variables from static_routes.yml:
#   - switches.<hostname>.routes: List of static routes including default gateway
#
# Variables from l3_interfaces.yml:
#   - switches.<hostname>.interfaces: L3 interface configurations with IP addresses
#
# Module Used:
#   - cisco.dcnm.dcnm_inventory: Inventory merge for POAP pre-provisioning and switch discovery
#
# Tags:
#   - preprovision-switches: Run only switch pre-provisioning tasks
#   - discover-switches: Run only switch discovery tasks
#
# Example Usage:
#   ansible-playbook ./playbooks/1.0-preprovision-new-switches.yml
#   ansible-playbook ./playbooks/1.0-preprovision-new-switches.yml --tags preprovision-switches
#   ansible-playbook ./playbooks/1.0-preprovision-new-switches.yml --tags discover-switches

- name: Pre-provision New Switches to NDFC
  hosts: nexus_dashboard
  gather_facts: false

  tags:
    - preprovision-switches
    - discover-switches

  tasks:

    #--------------------------------------------------------------------------
    # Pre-flight: Verify NDFC is reachable before any provisioning
    #--------------------------------------------------------------------------
    - name: Verify NDFC connectivity
      ansible.builtin.import_tasks: ../common/ndfc-preflight-check.yml

    # Build list of switches to pre-provision from inventory
    - name: Build list of switches to pre-provision
      ansible.builtin.set_fact:
        switches_to_preprovision: >-
          {{
            groups['switches'] | default([])
            | map('extract', hostvars)
            | selectattr('add_to_fabric', 'defined')
            | selectattr('add_to_fabric', 'equalto', true)
            | list
          }}

    # Build fabric paths from nd_fabrics for targeted file searches
    - name: Build fabric paths from nd_fabrics
      ansible.builtin.import_tasks: ../common/build-fabric-paths.yml
      when: switches_to_preprovision | length > 0

    #--------------------------------------------------------------------------
    # Load switch_details.yml for workflow classification
    # Compare destination_switch_sn (hosts.yml) with serial_number (switch_details.yml):
    #   - Match    → Discovery workflow (existing switch, same hardware)
    #   - Mismatch → POAP pre-provisioning workflow (new switch replacing old)
    #--------------------------------------------------------------------------
    - name: Find switch_details.yml files for workflow classification
      ansible.builtin.find:
        paths: >-
          {{
            switches_to_preprovision
            | map(attribute='fabric') | unique
            | map('regex_replace', '^(.*)$', (fabric_paths_base_dir | default(playbook_dir ~ '/../../fabrics')) ~ '/\1')
            | list
          }}
        patterns: "switch_details.yml"
      register: switch_details_files_early
      delegate_to: localhost
      when: switches_to_preprovision | length > 0

    - name: Load switch details for workflow classification
      ansible.builtin.include_vars:
        file: "{{ item.path }}"
        name: "switch_details_early_{{ item.path | dirname | basename | replace('-', '_') }}"
      loop: "{{ switch_details_files_early.files | default([]) }}"
      loop_control:
        label: "{{ item.path | dirname | basename }}"
      when: switches_to_preprovision | length > 0

    - name: Build switch details lookup by IP for workflow classification
      ansible.builtin.set_fact:
        switch_details_by_ip: |
          {%- set lookup = {} -%}
          {%- for var_name in hostvars[inventory_hostname] | select('match', '^switch_details_early_') -%}
            {%- set details = hostvars[inventory_hostname][var_name] -%}
            {%- if details.switches is defined -%}
              {%- for sw in details.switches -%}
                {%- set _ = lookup.update({sw.ip_address: sw}) -%}
              {%- endfor -%}
            {%- endif -%}
          {%- endfor -%}
          {{ lookup }}
      when: switches_to_preprovision | length > 0

    # Separate switches into POAP (serial mismatch) and Discovery (serial match)
    # destination_switch_sn matches switch_details serial_number → Discovery
    # destination_switch_sn does NOT match switch_details serial_number → POAP
    - name: Separate switches by provisioning method
      ansible.builtin.set_fact:
        switches_for_poap: |
          {%- set poap_list = [] -%}
          {%- for switch in switches_to_preprovision -%}
            {%- set dest_sn = switch.destination_switch_sn | default('') -%}
            {%- set ip = switch.ansible_host | default('') -%}
            {%- set details = switch_details_by_ip.get(ip, {}) if switch_details_by_ip is defined else {} -%}
            {%- set current_sn = details.get('serial_number', '') -%}
            {%- if dest_sn and current_sn and dest_sn != current_sn
                and switch.destination_switch_model is defined
                and switch.destination_switch_version is defined -%}
              {%- set _ = poap_list.append(switch) -%}
            {%- endif -%}
          {%- endfor -%}
          {{ poap_list }}
        switches_for_discovery: |
          {%- set disc_list = [] -%}
          {%- for switch in switches_to_preprovision -%}
            {%- set dest_sn = switch.destination_switch_sn | default('') -%}
            {%- set ip = switch.ansible_host | default('') -%}
            {%- set details = switch_details_by_ip.get(ip, {}) if switch_details_by_ip is defined else {} -%}
            {%- set current_sn = details.get('serial_number', '') -%}
            {%- if not dest_sn or not current_sn or dest_sn == current_sn -%}
              {%- set _ = disc_list.append(switch) -%}
            {%- endif -%}
          {%- endfor -%}
          {{ disc_list }}
      when: switches_to_preprovision | length > 0

    - name: Display workflow classification
      ansible.builtin.debug:
        msg: |
          ═══════════════════════════════════════════════════════════════════════
          WORKFLOW CLASSIFICATION (destination_switch_sn vs switch_details serial)
          ═══════════════════════════════════════════════════════════════════════
          POAP Pre-provisioning (serial mismatch - new hardware): {{ switches_for_poap | length }}
          {% for sw in switches_for_poap %}
          - {{ sw.inventory_hostname }}: destination_sn={{ sw.destination_switch_sn }} ≠ switch_details_sn={{ switch_details_by_ip.get(sw.ansible_host, {}).get('serial_number', 'N/A') }}
          {% endfor %}
          Discovery (serial match - existing hardware): {{ switches_for_discovery | length }}
          {% for sw in switches_for_discovery %}
          {%- set dest_sn = sw.destination_switch_sn | default('N/A') -%}
          {%- set current_sn = switch_details_by_ip.get(sw.ansible_host, {}).get('serial_number', 'N/A') -%}
          - {{ sw.inventory_hostname }}: destination_sn={{ dest_sn }}, switch_details_sn={{ current_sn }}
          {% endfor %}
          ═══════════════════════════════════════════════════════════════════════
      when: switches_to_preprovision | length > 0

    #--------------------------------------------------------------------------
    # Load static routes data for gateway info
    #--------------------------------------------------------------------------
    - name: Find all static_routes.yml files
      ansible.builtin.find:
        paths: >-
          {{
            switches_for_poap | default([])
            | map(attribute='fabric') | unique
            | map('regex_replace', '^(.*)$', (fabric_paths_base_dir | default(playbook_dir ~ '/../../fabrics')) ~ '/\1')
            | list
          }}
        patterns: "static_routes.yml"
      register: static_routes_files
      when: switches_for_poap is defined and switches_for_poap | length > 0

    - name: Load static routes data from all fabrics
      ansible.builtin.include_vars:
        file: "{{ item.path }}"
        name: "routes_data_{{ item.path | dirname | basename }}"
      loop: "{{ static_routes_files.files | default([]) }}"
      loop_control:
        label: "{{ item.path | dirname | basename }}"
      when: switches_for_poap is defined and switches_for_poap | length > 0

    - name: Build consolidated static routes lookup
      ansible.builtin.set_fact:
        static_routes_lookup: |
          {%- set lookup = {} -%}
          {%- for file in static_routes_files.files | default([]) -%}
            {%- set fabric_name = file.path | dirname | basename -%}
            {%- set var_name = 'routes_data_' + fabric_name -%}
            {%- if hostvars[inventory_hostname][var_name] is defined -%}
              {%- set fabric_data = hostvars[inventory_hostname][var_name] -%}
              {%- if fabric_data.switches is defined -%}
                {%- for hostname, data in fabric_data.switches.items() -%}
                  {%- set _ = lookup.update({hostname: data | combine({'fabric': fabric_name})}) -%}
                {%- endfor -%}
              {%- endif -%}
            {%- endif -%}
          {%- endfor -%}
          {{ lookup }}
      when: switches_for_poap is defined and switches_for_poap | length > 0

    #--------------------------------------------------------------------------
    # Load L3 interface data for management IP prefix
    #--------------------------------------------------------------------------
    - name: Find all l3_interfaces.yml files
      ansible.builtin.find:
        paths: >-
          {{
            switches_for_poap | default([])
            | map(attribute='fabric') | unique
            | map('regex_replace', '^(.*)$', (fabric_paths_base_dir | default(playbook_dir ~ '/../../fabrics')) ~ '/\1')
            | list
          }}
        patterns: "l3_interfaces.yml"
      register: l3_interfaces_files
      when: switches_for_poap is defined and switches_for_poap | length > 0

    - name: Load L3 interface data from all fabrics
      ansible.builtin.include_vars:
        file: "{{ item.path }}"
        name: "l3_data_{{ item.path | dirname | basename }}"
      loop: "{{ l3_interfaces_files.files | default([]) }}"
      loop_control:
        label: "{{ item.path | dirname | basename }}"
      when: switches_for_poap is defined and switches_for_poap | length > 0

    - name: Build consolidated L3 interfaces lookup
      ansible.builtin.set_fact:
        l3_interfaces_lookup: |
          {%- set lookup = {} -%}
          {%- for file in l3_interfaces_files.files | default([]) -%}
            {%- set fabric_name = file.path | dirname | basename -%}
            {%- set var_name = 'l3_data_' + fabric_name -%}
            {%- if hostvars[inventory_hostname][var_name] is defined -%}
              {%- set fabric_data = hostvars[inventory_hostname][var_name] -%}
              {%- if fabric_data.switches is defined -%}
                {%- for hostname, data in fabric_data.switches.items() -%}
                  {%- set _ = lookup.update({hostname: {'interfaces': data.interfaces | default([]), 'fabric': fabric_name}}) -%}
                {%- endfor -%}
              {%- endif -%}
            {%- endif -%}
          {%- endfor -%}
          {{ lookup }}
      when: switches_for_poap is defined and switches_for_poap | length > 0

    # Build pre-provision profiles for each switch (POAP only - serial mismatch)
    - name: Build pre-provision profiles
      ansible.builtin.set_fact:
        preprovision_profiles: |
          {%- set profiles = [] -%}
          {%- for switch in switches_for_poap | default([]) -%}
            {%- set hostname = switch.inventory_hostname -%}
            {%- set mgmt_int = switch.mgmt_int | default('Vlan199') -%}
            {%- if switch.destination_switch_sn is defined and 
                   switch.destination_switch_model is defined and
                   switch.destination_switch_version is defined and
                   switch.ansible_host is defined -%}
              {# Get default route from static_routes_lookup #}
              {%- set routes_data = static_routes_lookup.get(hostname, {}) -%}
              {%- set all_default_routes = routes_data.routes | default([]) | selectattr('prefix', 'equalto', '0.0.0.0/0') | list -%}
              {# Filter for routes with matching interface, handling missing interface attribute #}
              {%- set matching_routes = [] -%}
              {%- for route in all_default_routes -%}
                {%- if route.interface is defined and route.interface == mgmt_int -%}
                  {%- set _ = matching_routes.append(route) -%}
                {%- endif -%}
              {%- endfor -%}
              {# Fallback to any default route if no interface-specific route found #}
              {%- set default_route = matching_routes | first | default(all_default_routes | first | default({})) -%}
              {%- set gateway_ip = default_route.next_hop | default('') -%}
              {# Get management interface prefix from l3_interfaces_lookup #}
              {%- set l3_data = l3_interfaces_lookup.get(hostname, {}) -%}
              {%- set mgmt_iface = l3_data.interfaces | default([]) | selectattr('name', 'equalto', mgmt_int) | list | first | default({}) -%}
              {%- set mgmt_ip = mgmt_iface.ipv4_address | default('') -%}
              {%- set gateway_prefix = mgmt_ip.split('/')[1] | default('24') if mgmt_ip else '24' -%}
              {%- set gateway = gateway_ip + '/' + gateway_prefix if gateway_ip else '' -%}
              {%- set profile = {
                'fabric': switch.fabric,
                'hostname': hostname,
                'serial_number': switch.destination_switch_sn,
                'model': switch.destination_switch_model,
                'version': switch.destination_switch_version,
                'ip_address': switch.ansible_host,
                'role': switch.role,
                'gateway': gateway
              } -%}
              {%- set _ = profiles.append(profile) -%}
            {%- endif -%}
          {%- endfor -%}
          {{ profiles }}
      when: switches_for_poap is defined and switches_for_poap | length > 0

    # Group profiles by fabric for batch API calls
    - name: Group pre-provision profiles by fabric
      ansible.builtin.set_fact:
        preprovision_by_fabric: |
          {%- set by_fabric = {} -%}
          {%- for profile in preprovision_profiles -%}
            {%- if profile.fabric not in by_fabric -%}
              {%- set _ = by_fabric.update({profile.fabric: []}) -%}
            {%- endif -%}
            {%- set _ = by_fabric[profile.fabric].append(profile) -%}
          {%- endfor -%}
          {{ by_fabric }}
      when:
        - switches_for_poap is defined and switches_for_poap | length > 0
        - preprovision_profiles | length > 0

    - name: Build POAP inventory payloads for dcnm_inventory
      ansible.builtin.set_fact:
        poap_inventory_by_fabric: |
          {%- set by_fabric = {} -%}
          {%- for fabric, switches in preprovision_by_fabric.items() -%}
            {%- set entries = [] -%}
            {%- for sw in switches -%}
              {%- set poap_entry = {
                'seed_ip': sw.ip_address,
                'user_name': 'admin',
                'password': nd_switch_password,
                'role': sw.role,
                'poap': [{
                  'preprovision_serial': sw.serial_number,
                  'model': sw.model,
                  'version': sw.version,
                  'hostname': sw.hostname,
                  'discovery_username': vault_nd_discovery_user | default(''),
                  'discovery_password': vault_nd_discovery_password | default(''),
                  'config_data': {
                    'modulesModel': [sw.model],
                    'gateway': sw.gateway
                  }
                }]
              } -%}
              {%- set _ = entries.append(poap_entry) -%}
            {%- endfor -%}
            {%- if entries | length > 0 -%}
              {%- set _ = by_fabric.update({fabric: entries}) -%}
            {%- endif -%}
          {%- endfor -%}
          {{ by_fabric }}
      when:
        - preprovision_by_fabric is defined
        - preprovision_by_fabric | length > 0

    - name: Display switches to pre-provision
      ansible.builtin.debug:
        msg: |
          Switches to pre-provision: {{ poap_inventory_by_fabric | dict2items | map(attribute='value') | flatten | length }}
          {% for fabric, switches in poap_inventory_by_fabric.items() %}
          - {{ fabric }}: {% for sw in switches %}{{ sw.poap[0].hostname }}{% if not loop.last %}, {% endif %}{% endfor %}
          {% endfor %}
      when: poap_inventory_by_fabric is defined

    - name: Pre-provision switches to NDFC via dcnm_inventory
      cisco.dcnm.dcnm_inventory:
        fabric: "{{ item.key }}"
        state: merged
        save: false
        deploy: false
        config: "{{ item.value }}"
      vars:
        ansible_network_os: cisco.dcnm.dcnm
      loop: "{{ poap_inventory_by_fabric | default({}) | dict2items }}"
      loop_control:
        label: "{{ item.key }} ({{ item.value | length }} switches)"
      when:
        - poap_inventory_by_fabric is defined
        - poap_inventory_by_fabric | length > 0
      register: preprovision_results

    - name: Display pre-provisioning results
      ansible.builtin.debug:
        msg: |
          Pre-provisioning complete via dcnm_inventory.
          {% for result in preprovision_results.results | default([]) %}
          {% if result.skipped is not defined or not result.skipped %}
          - {{ result.item.key }}: {{ 'SUCCESS' if result.failed is not defined or not result.failed else 'FAILED' }}
          {% endif %}
          {% endfor %}
      when: preprovision_results is defined

    # Capture POAP switch hostnames to exclude from role assignment
    # POAP switches already have roles assigned during pre-provisioning
    - name: Build list of POAP switch hostnames
      ansible.builtin.set_fact:
        poap_switch_hostnames: |
          {%- set hostnames = [] -%}
          {%- for profile in preprovision_profiles | default([]) -%}
            {%- if profile.hostname is defined -%}
              {%- set _ = hostnames.append(profile.hostname) -%}
            {%- endif -%}
          {%- endfor -%}
          {{ hostnames }}
      when: preprovision_profiles is defined

    - name: Display POAP switches excluded from role assignment
      ansible.builtin.debug:
        msg: |
          POAP switches (role already assigned during pre-provisioning): {{ poap_switch_hostnames | length }}
          Hostnames: {{ poap_switch_hostnames | join(', ') if poap_switch_hostnames | length > 0 else 'None' }}
      when: poap_switch_hostnames is defined and poap_switch_hostnames | length > 0

    #==========================================================================
    # DISCOVERY WORKFLOW - For existing switches without destination_switch_sn
    #==========================================================================

    # Load switch_details.yml to get serial numbers for discovery and role assignment
    - name: Build fabric paths for discovery (only fabrics containing switches to discover)
      ansible.builtin.set_fact:
        discovery_fabric_paths: >-
          {{
            switches_for_discovery | default([])
            | map(attribute='fabric') | unique
            | map('regex_replace', '^(.*)$', (fabric_paths_base_dir | default(playbook_dir ~ '/../../fabrics')) ~ '/\1')
            | list
          }}
      tags:
        - discover-switches
        - assign-roles

    - name: Find switch_details.yml files for discovery
      ansible.builtin.find:
        paths: "{{ discovery_fabric_paths }}"
        patterns: "switch_details.yml"
      register: switch_details_files
      delegate_to: localhost
      tags:
        - discover-switches
        - assign-roles

    - name: Load switch details for discovery
      ansible.builtin.include_vars:
        file: "{{ item.path }}"
        name: "switch_details_{{ item.path | dirname | basename }}"
      loop: "{{ switch_details_files.files | default([]) }}"
      loop_control:
        label: "{{ item.path | dirname | basename }}"
      when: switch_details_files.files is defined and switch_details_files.files | length > 0
      tags:
        - discover-switches
        - assign-roles

    - name: Build consolidated switch details lookup
      ansible.builtin.set_fact:
        switch_details_lookup: |
          {%- set lookup = {} -%}
          {%- for fabric_file in switch_details_files.files | default([]) -%}
            {%- set fabric_name = fabric_file.path | dirname | basename -%}
            {%- set var_name = 'switch_details_' ~ fabric_name -%}
            {%- if hostvars[inventory_hostname][var_name] is defined -%}
              {%- set details = hostvars[inventory_hostname][var_name] -%}
              {%- if details.switches is defined -%}
                {%- for sw in details.switches -%}
                  {%- set sw_with_fabric = sw | combine({'fabric': fabric_name}) -%}
                  {%- set _ = lookup.update({sw.ip_address: sw_with_fabric}) -%}
                {%- endfor -%}
              {%- endif -%}
            {%- endif -%}
          {%- endfor -%}
          {{ lookup }}
      when: switch_details_files.files is defined and switch_details_files.files | length > 0
      tags:
        - discover-switches
        - assign-roles

    # Build discovery profiles for switches without serial numbers
    - name: Build discovery profiles
      ansible.builtin.set_fact:
        discovery_profiles: |
          {%- set profiles = [] -%}
          {%- for switch in switches_for_discovery | default([]) -%}
            {%- set hostname = switch.inventory_hostname -%}
            {%- if switch.ansible_host is defined and switch.fabric is defined -%}
              {%- set details = switch_details_lookup.get(switch.ansible_host, {}) if switch_details_lookup is defined else {} -%}
              {%- set profile = {
                'fabric': switch.fabric,
                'hostname': hostname,
                'ip_address': switch.ansible_host,
                'role': switch.role | default('access'),
                'serial_number': details.get('license_hostid', ''),
                'model': details.get('model', ''),
                'software_version': details.get('software_version', '')
              } -%}
              {%- set _ = profiles.append(profile) -%}
            {%- endif -%}
          {%- endfor -%}
          {{ profiles }}
      when: switches_for_discovery is defined and switches_for_discovery | length > 0
      tags:
        - discover-switches

    # Build flat per-switch discovery payloads (one entry per switch)
    # Using per-switch calls avoids a dcnm_inventory bug where mixing already-managed
    # and new switches in the same batch causes new switches to be silently skipped.
    - name: Build per-switch discovery payloads
      ansible.builtin.set_fact:
        discovery_payloads: |
          {%- set payloads = [] -%}
          {%- for sw in discovery_profiles | default([]) -%}
            {%- set entry = {
              'fabric': sw.fabric,
              'hostname': sw.hostname,
              'config': [{
                'seed_ip': sw.ip_address,
                'auth_proto': discovery_auth_proto | default('MD5'),
                'user_name': vault_nd_discovery_user,
                'password': vault_nd_discovery_password,
                'max_hops': 0,
                'role': sw.role,
                'preserve_config': preserve_config | default(true) | bool
              }]
            } -%}
            {%- set _ = payloads.append(entry) -%}
          {%- endfor -%}
          {{ payloads }}
      when:
        - discovery_profiles is defined
        - discovery_profiles | length > 0
      tags:
        - discover-switches
        - assign-roles

    # Filter already-managed switches from discovery payloads.
    # When a switch is already managed in NDFC, dcnm_inventory POSTs to
    # /inventory/discover with selectable=false, NDFC returns a response with
    # no DATA field, and the dcnm_inventory failure() method crashes with
    # NoneType.get(). Skip these switches entirely — they are already managed.
    #
    # cisco.dcnm.dcnm_rest is used here instead of cisco.nd.nd_rest because:
    # - cisco.nd.nd_rest returns 403 Forbidden on NDFC LAN Fabric REST endpoints
    #   when called via the ND httpapi connection plugin.
    # - cisco.dcnm.dcnm_rest routes requests through the DCNM/NDFC httpapi plugin,
    #   which handles NDFC-specific authentication and produces a 200 response.
    # - Response shape differs: dcnm_rest returns result.response.DATA (dict),
    #   whereas nd_rest returns result.json.DATA directly.
    - name: Query NDFC for already-managed switches per fabric
      cisco.dcnm.dcnm_rest:
        method: GET
        path: "/appcenter/cisco/ndfc/api/v1/lan-fabric/rest/control/fabrics/{{ item }}/inventory/switchesByFabric"
      vars:
        ansible_network_os: cisco.dcnm.dcnm
      loop: "{{ discovery_payloads | default([]) | map(attribute='fabric') | unique | list }}"
      loop_control:
        label: "{{ item }}"
      register: ndfc_managed_switches_raw
      when: discovery_payloads is defined and discovery_payloads | length > 0
      tags:
        - discover-switches
        - assign-roles

    - name: Build set of already-managed switch IPs
      ansible.builtin.set_fact:
        managed_switch_ips: |
          {%- set ips = [] -%}
          {%- for result in ndfc_managed_switches_raw.results | default([]) -%}
            {%- if result.skipped is not defined and result.response is defined and result.response.DATA is defined -%}
              {%- for sw in result.response.DATA | default([]) -%}
                {%- if sw.ipAddress is defined -%}
                  {%- set _ = ips.append(sw.ipAddress) -%}
                {%- endif -%}
              {%- endfor -%}
            {%- endif -%}
          {%- endfor -%}
          {{ ips }}
      when: ndfc_managed_switches_raw is defined
      tags:
        - discover-switches
        - assign-roles

    - name: Filter already-managed switches from discovery payloads
      ansible.builtin.set_fact:
        discovery_payloads: |
          {%- set filtered = [] -%}
          {%- for payload in discovery_payloads | default([]) -%}
            {%- if payload.config[0].seed_ip not in (managed_switch_ips | default([])) -%}
              {%- set _ = filtered.append(payload) -%}
            {%- endif -%}
          {%- endfor -%}
          {{ filtered }}
      when:
        - discovery_payloads is defined
        - managed_switch_ips is defined
      tags:
        - discover-switches
        - assign-roles

    - name: Display switches to discover
      ansible.builtin.debug:
        msg: |
          ═══════════════════════════════════════════════════════════════════════
          SWITCH DISCOVERY
          ═══════════════════════════════════════════════════════════════════════
          Switches to discover: {{ discovery_payloads | default([]) | length }}
          {% for sw in discovery_payloads | default([]) %}
          - {{ sw.fabric }}: {{ sw.hostname }} ({{ sw.config[0].seed_ip }}, role={{ sw.config[0].role }})
          {% endfor %}
          ═══════════════════════════════════════════════════════════════════════
      when: discovery_payloads is defined
      tags:
        - discover-switches
        - assign-roles

    - name: Discover existing switches and assign roles via dcnm_inventory
      cisco.dcnm.dcnm_inventory:
        fabric: "{{ item.fabric }}"
        state: merged
        save: false
        deploy: false
        config: "{{ item.config }}"
      vars:
        ansible_network_os: cisco.dcnm.dcnm
        ansible_command_timeout: 1000
        ansible_connect_timeout: 1000
      loop: "{{ discovery_payloads | default([]) }}"
      loop_control:
        label: "{{ item.fabric }}/{{ item.hostname }}"
      when:
        - discovery_payloads is defined
        - discovery_payloads | length > 0
      register: discovery_results
      tags:
        - discover-switches
        - assign-roles

    - name: Display discovery results
      ansible.builtin.debug:
        msg: |
          ═══════════════════════════════════════════════════════════════════════
          DISCOVERY RESULTS
          ═══════════════════════════════════════════════════════════════════════
          {% for result in discovery_results.results | default([]) %}
          {% if result.skipped is not defined or not result.skipped %}
          - {{ result.item.fabric }}/{{ result.item.hostname }}: {{ 'SUCCESS' if result.failed is not defined or not result.failed else 'FAILED' }}
          {% endif %}
          {% endfor %}
          ═══════════════════════════════════════════════════════════════════════
      when: discovery_results is defined
      tags:
        - discover-switches
        - assign-roles
