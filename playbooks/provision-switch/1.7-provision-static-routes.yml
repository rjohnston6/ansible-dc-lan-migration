---
# Playbook: 1.7-provision-static-routes.yml
# Purpose: Configure default static route on pre-provisioned switches via NDFC
#
# Description:
#   This playbook configures default static routes on switches by:
#   1. Loading static_routes.yml to find default gateway configuration
#   2. Filtering switches with add_to_fabric: true
#   3. Creating static route policy via bulk-create API
#
# Prerequisites:
#   - Run 1.4-provision-vlan-policies.yml first
#   - Run discovery playbook to generate static_routes.yml
#
# Variables Required (per switch in hosts.yml):
#   - add_to_fabric: Set to true to include switch in provisioning
#   - fabric: Target fabric name
#   - destination_switch_sn: Target switch serial number
#   - mgmt_int: Management interface name (e.g., Vlan199)
#
# Variables from static_routes.yml:
#   - switches.<hostname>.routes: List of static routes including default route
#
# API Endpoints Used:
#   - POST /appcenter/cisco/ndfc/api/v1/lan-fabric/rest/control/policies/bulk-create
#   - GET /appcenter/cisco/ndfc/api/v1/lan-fabric/rest/control/policies/switches/<serial>
#
# Templates Used:
#   - 1.7-provision-static-routes.j2: JSON template for static route policy
#
# Tags:
#   - preprovision-default-route: Run only default route provisioning tasks
#
# Example Usage:
#   ansible-playbook ./playbooks/provision-switch/1.7-provision-static-routes.yml
#   ansible-playbook ./playbooks/provision-switch/1.7-provision-static-routes.yml --tags preprovision-default-route

- name: Configure Default Routes on Pre-provisioned Switches
  hosts: nexus_dashboard
  gather_facts: false

  tags:
    - preprovision-default-route

  tasks:

    #--------------------------------------------------------------------------
    # Pre-flight: Verify NDFC is reachable before any provisioning
    #--------------------------------------------------------------------------
    - name: Verify NDFC connectivity
      ansible.builtin.import_tasks: ../common/ndfc-preflight-check.yml

    # Build list of switches to provision
    - name: Build list of switches to provision
      ansible.builtin.set_fact:
        switches_to_provision: >-
          {{
            groups['switches'] | default([])
            | map('extract', hostvars)
            | selectattr('add_to_fabric', 'defined')
            | selectattr('add_to_fabric', 'equalto', true)
            | list
          }}

    # Build fabric paths from nd_fabrics for targeted file searches
    - name: Build fabric paths from nd_fabrics
      ansible.builtin.import_tasks: ../common/build-fabric-paths.yml
      when: switches_to_provision | length > 0

    #--------------------------------------------------------------------------
    # Load static routes data
    #--------------------------------------------------------------------------
    - name: Find all static_routes.yml files
      ansible.builtin.find:
        paths: "{{ fabric_paths }}"
        patterns: "static_routes.yml"
      register: static_routes_files
      when: switches_to_provision | length > 0

    - name: Load static routes data from all fabrics
      ansible.builtin.include_vars:
        file: "{{ item.path }}"
        name: "routes_data_{{ item.path | dirname | basename }}"
      loop: "{{ static_routes_files.files | default([]) }}"
      loop_control:
        label: "{{ item.path | dirname | basename }}"
      when: switches_to_provision | length > 0

    - name: Build consolidated static routes lookup
      ansible.builtin.set_fact:
        static_routes_lookup: |
          {%- set lookup = {} -%}
          {%- for file in static_routes_files.files | default([]) -%}
            {%- set fabric_name = file.path | dirname | basename -%}
            {%- set var_name = 'routes_data_' + fabric_name -%}
            {%- if hostvars[inventory_hostname][var_name] is defined -%}
              {%- set fabric_data = hostvars[inventory_hostname][var_name] -%}
              {%- if fabric_data.switches is defined -%}
                {%- for hostname, data in fabric_data.switches.items() -%}
                  {%- set _ = lookup.update({hostname: data | combine({'fabric': fabric_name})}) -%}
                {%- endfor -%}
              {%- endif -%}
            {%- endif -%}
          {%- endfor -%}
          {{ lookup }}
      when: switches_to_provision | length > 0

    # Extract static route configurations (default routes only)
    - name: Build static route configurations
      ansible.builtin.set_fact:
        static_routes: |
          {%- set routes = [] -%}
          {%- for switch in switches_to_provision -%}
            {%- set hostname = switch.inventory_hostname -%}
            {%- set serial = switch.destination_switch_sn | default('') -%}
            {%- set fabric = switch.fabric | default('') -%}
            {%- set mgmt_int = switch.mgmt_int | default('Vlan199') -%}
            {%- if serial and hostname in static_routes_lookup -%}
              {%- set routes_data = static_routes_lookup[hostname] -%}
              {# Find default route (0.0.0.0/0) #}
              {%- for route in routes_data.routes | default([]) -%}
                {%- if route.prefix == '0.0.0.0/0' -%}
                  {%- set vrf = route.vrf | default('') -%}
                  {%- if vrf == 'default' -%}
                    {%- set vrf = '' -%}
                  {%- endif -%}
                  {%- set route_config = {
                    'hostname': hostname,
                    'serial_number': serial,
                    'fabric_name': fabric,
                    'next_hop': route.next_hop,
                    'prefix': '0.0.0.0/0',
                    'interface': route.interface | default(mgmt_int),
                    'vrf_name': vrf,
                    'description': 'Default route'
                  } -%}
                  {%- set _ = routes.append(route_config) -%}
                {%- endif -%}
              {%- endfor -%}
            {%- endif -%}
          {%- endfor -%}
          {{ routes }}
      when: switches_to_provision | length > 0

    # Query existing policies per switch to make playbook idempotent
    - name: Get unique serial numbers from static routes
      ansible.builtin.set_fact:
        unique_serials: "{{ static_routes | map(attribute='serial_number') | unique | list }}"
      when:
        - static_routes is defined
        - static_routes | length > 0

    - name: Query existing policies for each switch
      cisco.nd.nd_rest:
        host: "{{ ansible_host }}"
        username: "{{ ansible_user }}"
        password: "{{ ansible_ssh_pass }}"
        use_ssl: "{{ ansible_httpapi_use_ssl }}"
        validate_certs: "{{ ansible_httpapi_validate_certs }}"
        use_proxy: "{{ ansible_httpapi_use_proxy }}"
        login_domain: "{{ ansible_httpapi_login_domain }}"
        path: "/appcenter/cisco/ndfc/api/v1/lan-fabric/rest/control/policies/switches/{{ item }}"
        method: GET
      loop: "{{ unique_serials | default([]) }}"
      loop_control:
        label: "{{ item }}"
      when:
        - unique_serials is defined
        - unique_serials | length > 0
      register: existing_policies_query
      ignore_errors: true

    - name: Build set of existing static route policies per serial
      ansible.builtin.set_fact:
        existing_static_routes_lookup: |
          {%- set lookup = {} -%}
          {%- for result in existing_policies_query.results | default([]) -%}
            {%- if result.current is defined and result.current is iterable and result.current is not string -%}
              {%- set serial = result.item -%}
              {%- set templates = result.current | map(attribute='templateName') | list -%}
              {%- set has_static_route = 'static_route_v4_v6' in templates -%}
              {%- set _ = lookup.update({serial: has_static_route}) -%}
            {%- endif -%}
          {%- endfor -%}
          {{ lookup }}
      when: existing_policies_query is defined

    - name: Filter out switches with existing static route policies
      ansible.builtin.set_fact:
        static_routes_filtered: |
          {%- set filtered = [] -%}
          {%- for route in static_routes -%}
            {%- set serial = route.serial_number -%}
            {%- set has_existing = existing_static_routes_lookup.get(serial, false) -%}
            {%- if not has_existing -%}
              {%- set _ = filtered.append(route) -%}
            {%- endif -%}
          {%- endfor -%}
          {{ filtered }}
      when:
        - static_routes is defined
        - existing_static_routes_lookup is defined

    - name: Display static routes to configure (after filtering existing)
      ansible.builtin.debug:
        msg: |
          Static routes to configure (excluding existing): {{ static_routes_filtered | length }}
          Already configured (skipped): {{ (static_routes | length) - (static_routes_filtered | length) }}
          {% for route in static_routes_filtered %}
          - {{ route.hostname }}: {{ route.prefix }} via {{ route.next_hop }}{% if route.interface %} ({{ route.interface }}){% endif %}
          {% endfor %}
      when: static_routes_filtered is defined

    # Configure static routes via NDFC API
    # ========================================================================

    - name: Build static route policy configs grouped by fabric for dcnm_policy
      ansible.builtin.set_fact:
        route_policy_by_fabric: |
          {%- set by_fabric = {} -%}
          {%- for route in static_routes_filtered | default([]) -%}
            {%- set fabric = route.fabric_name -%}
            {%- set ip = hostvars[route.hostname]['ansible_host'] -%}
            {%- if fabric not in by_fabric -%}
              {%- set _ = by_fabric.update({fabric: {}}) -%}
            {%- endif -%}
            {%- if ip not in by_fabric[fabric] -%}
              {%- set _ = by_fabric[fabric].update({ip: []}) -%}
            {%- endif -%}
            {%- set static_routes_json = '{"staticRoutes":[{"IP_VERSION":"IPv4","ipv4Prefix":"' + route.prefix + '","ipv6Prefix":"","nextHop":"' + route.next_hop + '","interface":"' + (route.interface | default('')) + '","routePreference":"","nextHopName":"","tag":"","trackId":"","nextHopVrf":""}]}' -%}
            {%- set _ = by_fabric[fabric][ip].append({
              'name': 'static_route_v4_v6',
              'create_additional_policy': true,
              'policy_vars': {
                'vrfName': route.vrf_name | default(''),
                'staticRoutes': static_routes_json
              }
            }) -%}
          {%- endfor -%}
          {%- set result = {} -%}
          {%- for fabric, switches in by_fabric.items() -%}
            {%- set config = [{'switch': []}] -%}
            {%- for ip, policies in switches.items() -%}
              {%- set _ = config[0].switch.append({'ip': ip, 'policies': policies}) -%}
            {%- endfor -%}
            {%- set _ = result.update({fabric: config}) -%}
          {%- endfor -%}
          {{ result }}
      when:
        - static_routes_filtered is defined
        - static_routes_filtered | length > 0

    # Configure static routes via dcnm_policy (avoids 403 on bulk-create with nd_rest)
    - name: Configure default static routes on switches
      cisco.dcnm.dcnm_policy:
        fabric: "{{ item.key }}"
        state: merged
        deploy: false
        config: "{{ item.value }}"
      vars:
        ansible_network_os: cisco.dcnm.dcnm
      loop: "{{ route_policy_by_fabric | default({}) | dict2items }}"
      loop_control:
        label: "{{ item.key }}"
      when:
        - route_policy_by_fabric is defined
        - route_policy_by_fabric | length > 0
      register: route_results

    - name: Display static route configuration results
      ansible.builtin.debug:
        msg: |
          Static route configuration complete.
          Total routes found:        {{ static_routes | default([]) | length }}
          Already existed (skipped): {{ (static_routes | default([]) | length) - (static_routes_filtered | default([]) | length) }}
          Newly configured:          {{ static_routes_filtered | default([]) | length }}
          {% for result in route_results.results | default([]) %}
          {% if result.skipped is not defined or not result.skipped %}
          {{ result.item.key }}: {{ 'SUCCESS' if (result.failed is not defined or not result.failed) else 'FAILED' }}
          {% endif %}
          {% endfor %}
          {% if static_routes | default([]) | length == 0 %}
          WARNING: No static routes were found. Verify static_routes.yml is populated and switches have add_to_fabric: true.
          {% endif %}
